#' Random Rotation Matrix
#' 
#' Generate various rotation matrices by different distributions.
#'
#' @param dimX the number of dimensions.
#' @param randDist The probability distribution of the random projection direction from. "Binary", "Norm", "Uniform" denote the B{-1,1} 
#' binomial distribution (default), N(0,1) normal distribution and U(-1,1) uniform distribution, respectively.
#' @param numProj the number of desired columns in the projection matrix, is also the number of projection directions.(default ceiling(sqrt(dimX)))
#' @param dimProj Number of variables to be projected, default dimProj="Rand": random from 1 to ncol(X).
#' @param sparsity a real number in \eqn{(0,1)} that specifies the distribution of non-zero elements in the random matrix. 
#' When sparsity="pois" means that non-zero elements are generated by the p(\code{lambda}) Poisson distribution.
#' @param prob a probability \eqn{\in (0,1)} used for sampling from.
#' \eqn{{-1,1}} where \code{prob = 0} will only sample -1 and \code{prob = 1} will only sample 1.
#' @param lambda Parameter of the Poisson distribution (default 1).
#' @param catLabel A category labels of class \code{list} in prediction variables，for details see Examples of \code{\link{ODRF}}.
#' @param ... used to handle superfluous arguments passed in using paramList.
#'
#' @return \itemize{A random matrix to use in running \code{\link{ODT}}.
#' \item{Variable: variables to be projected.} 
#' \item{Number: Number of variables to be projected.}
#' \item{Coefficient: Coefficients of the projection matrix.}
#'}
#' @export
#'
#' @seealso \code{\link{RotMatPPO}} \code{\link{RotMatRF}} \code{\link{RotMatMake}}
#'
#' @examples
#' set.seed(1)
#' paramList <- list(dimX = 8, numProj= 3, sparsity=0.25, prob=0.5)
#' (RotMat <- do.call(RotMatRand, paramList))
#' paramList <- list(dimX = 8,numProj= 3,sparsity="pois")
#' (RotMat <- do.call(RotMatRand, paramList))
#' paramList <- list(dimX = 8, randDist="Norm", dimProj=5)
#' (RotMat <- do.call(RotMatRand, paramList))
RotMatRand <- function(dimX,randDist="Binary",numProj=ceiling(sqrt(dimX)),
                       dimProj = "Rand",sparsity=ifelse(dimX >=10, 3/dimX, 1/dimX),
                       prob=0.5, lambda=1, catLabel = NULL, ...) {
  if(!dimProj=="Rand"){
    if (dimProj > dimX) {
      stop("ERROR: parameter dimProj is greater than the number of dimensions dimX.")
    }
    
    nnz <- dimProj * numProj
    nz.rows <- integer(nnz)
    nz.cols <- integer(nnz)
    start.idx <- 1L
    for (i in seq.int(numProj)) {
      end.idx <- start.idx + dimProj - 1L
      nz.rows[start.idx:end.idx] <- sample.int(dimProj, dimProj, replace = FALSE)
      nz.cols[start.idx:end.idx] <- i
      start.idx <- end.idx + 1L
    }
  }else if(sparsity=="pois"){
    nnzPerCol <- stats::rpois(numProj, lambda)
    while (!any(nnzPerCol)) {
      nnzPerCol <- stats::rpois(numProj, lambda)
    }
    
    nnzPerCol[nnzPerCol > dimX] <- dimX
    nnz <- sum(nnzPerCol)
    nz.rows <- integer(nnz)
    nz.cols <- integer(nnz)
    start.idx <- 1L
    for (i in seq.int(numProj)) {
      if (nnzPerCol[i] != 0L) {
        end.idx <- start.idx + nnzPerCol[i] - 1L
        nz.rows[start.idx:end.idx] <- sample.int(dimX, nnzPerCol[i],replace = FALSE)
        nz.cols[start.idx:end.idx] <- i
        start.idx <- end.idx + 1L
      }
    }
  }else{
    nnzs <- round(dimX * numProj * sparsity)
    ind <- sort(sample.int((dimX * numProj), nnzs, replace = FALSE))
    nz.rows=((ind - 1L)%%dimX) + 1L
    nz.cols=floor((ind -1L)/dimX) + 1L
  }
  
  
  if(randDist=="Binary"){
    proj=sample(c(-1L,1L),length(nz.rows), replace = TRUE)
  }
  if(randDist=="Norm"){
    proj=rnorm(length(nz.rows))
  }
  if(randDist=="Uniform"){
    proj=runif(length(nz.rows), -1,1)
  }
  
  randomMatrix <- cbind(nz.rows, nz.cols, proj)

  ## Determine if categorical variables need to be taken d
  ## into consideration
  if (!is.null(catLabel)) {
    ind=randomMatrix[,1]; 
    catVar=which(ind<=length(catLabel))
    #catVar=which(ind<=length(catLabel))
    randomMatrix[-catVar, 1L]=randomMatrix[-catVar, 1L]+length(unlist(catLabel))-length(catLabel)
    
    catMap=1
    for (xj in unique(ind[catVar])) {
      isj=which(ind==xj)
      randomMatrix[isj, 1L]<- sample(catMap:(catMap+length(catLabel[[xj]])-1),length(isj),replace = TRUE)
      catMap=catMap+length(catLabel[[xj]])
    }
  }
  
  colnames(randomMatrix)=c("Variable","Number","Coefficient")
  return(randomMatrix)
}


#' Create a Projection Matrix: Random Forest (RF)
#'
#' Create a projection matrix with coefficient 1, so that ODRF (ODT) has the same partition variables as random forest (tree).
#'
#' @param dimX the number of dimensions.
#' @param numProj the number of desired columns in the projection matrix, is also the number of projection directions.(default ceiling(sqrt(dimX)))
#' @param catLabel A category labels of class \code{list} in prediction variables，for details see Examples of \code{\link{ODRF}}.
#' @param ... used to handle superfluous arguments passed in using paramList.
#'
#' @return \itemize{A random matrix to use in running \code{\link{ODT}}.
#' \item{Variable: variables to be projected.} 
#' \item{Number: Number of variables to be projected.}
#' \item{Coefficient: Coefficients of the projection matrix.}
#'}
#'
#' @export
#'
#' @seealso \code{\link{RotMatPPO}} \code{\link{RotMatRand}} \code{\link{RotMatMake}}
#'
#' @examples
#' paramList <- list(dimX = 8, numProj= 3, catLabel=NULL)
#' set.seed(2)
#' (RotMat <- do.call(RotMatRF, paramList))
RotMatRF <- function(dimX, numProj, catLabel = NULL, ...) {
  if (numProj > dimX) {
    stop("ERROR: parameter numProj is greater than the number of dimensions dimX.")
  }
  
  randomMatrix <- cbind(sample.int(dimX,numProj, replace = FALSE),1:numProj, rep(1L, numProj))
  if (!is.null(catLabel)) {
    ind=randomMatrix[,1]; 
    catVar=which(ind<=length(catLabel))
    #catVar=which(ind<=length(catLabel))
    randomMatrix[-catVar, 1L]=randomMatrix[-catVar, 1L]+length(unlist(catLabel))-length(catLabel)
    
    catMap=1
    for (xj in unique(ind[catVar])) {
      isj=which(ind==xj)
      randomMatrix[isj, 1L]<- sample(catMap:(catMap+length(catLabel[[xj]])-1),length(isj),replace = TRUE)
      catMap=catMap+length(catLabel[[xj]])
    }
  }
  
  colnames(randomMatrix)=c("Variable","Number","Coefficient")
  return(randomMatrix)
}


#################################################################################
#' Create a Projection Matrix: RotMatPPO
#' 
#' Create a projection matrix using projection pursuit optimization (\code{\link{PPO}}).
#'
#' @param X An n by d numeric matrix (preferable) or data frame.
#' @param y a n vector.
#' @param model model for projection pursuit.
#' @param type The criterion used for splitting the variable. 'g-classification': gini impurity index (classification, default), 
#'        'i-classification': information gain (classification) or 'regression': mean square error (regression).
#' @param weights A vector of length same as \code{data} that are positive weights. (default NULL)
#' @param dimProj Number of variables to be projected, \code{dimProj=min(ceiling(n^0.4),ceiling(ncol(X)*2/3))} (default) or \code{dimProj="Rand"}: random from 1 to ncol(X).
#' @param numProj the number of desired columns in the projection matrix, is also the number of projection directions.
#' When dimProj="Rand" default \code{numProj=max(5,sample(floor(ncol(X)/3),1))} otherwise default \code{numProj=max(5, ceiling(p0/dimProj))}.
#' @param catLabel A category labels of class \code{list} in prediction variables，for details see Examples of \code{\link{ODRF}}.
#' @param ... used to handle superfluous arguments passed in using paramList.
#'
#' @return \itemize{A random matrix to use in running \code{\link{ODT}}.
#' \item{Variable: variables to be projected.} 
#' \item{Number: Number of variables to be projected.}
#' \item{Coefficient: Coefficients of the projection matrix.}
#'}
#'
#' @importFrom stats rnorm lm ppr
#' @importFrom nnet nnet
#' @export
#'
#' @seealso \code{\link{RotMatMake}} \code{\link{RotMatRand}} \code{\link{RotMatRF}}
#'
#' @examples
#' X <- matrix(rnorm(200),20,10)
#' y <- (rnorm(20)>0)+0
#' set.seed(220828)
#' (RotMat <- RotMatPPO(X,y))
#' (RotMat <- RotMatPPO(X,y,dimProj="Rand"))
#' (RotMat <- RotMatPPO(X,y,dimProj=10,numProj=5))
RotMatPPO <- function(X, y, model="PPR",type='i-classification',weights=NULL,dimProj =min(ceiling(length(y)^0.4),ceiling(ncol(X)*2/3)),
                      numProj=ifelse(dimProj=="Rand",max(5,sample(floor(ncol(X)/3),1)),max(5, ceiling(ncol(X)/dimProj))),catLabel = NULL,...) {
  if (dimProj > ncol(X)) {
    stop("ERROR: parameter dimProj is greater than the number of dimensions.")
  }
  #cancor glm
  X=as.matrix(X)
  p = ncol(X)
  n=length(y)
  weights=if(is.null(weights))rep(1, n)
  #d=min(100, max(5, ceiling(p/q))) d q
  p0=p-(!is.null(catLabel))*(length(unlist(catLabel))-length(catLabel))
  
  d2=ceiling(sqrt(p0))
  ind <- sample(p0, d2, replace = FALSE)
  sparseM = cbind(ind, 1:d2, rep(1, d2))
  
  #ceiling(sqrt(p))#d#round(p/3)#
  #if((n>Q)&(n>10)&(p>1)){
  sparseM1=NULL
  if(n>10){
    if(dimProj=="Rand"){
      #if(is.null(numProj)){max(5,sample(floor(p0/3),1))}
      numProj=min(p0,numProj)
      d1=numProj
      spd=sample(p0,d1)
      indp=sum(spd)
      ind=unlist(sapply(spd,function(pd)sample(p0,pd)))
      sparseM1 <-cbind(ind, d2+rep(1:d1,spd) ,rep(1, indp))
    }else{
      #if(is.null(dimProj)){dimProj =min(ceiling(n^0.4),ceiling(p0*2/3))}
      #if(is.null(numProj)){numProj=max(5, ceiling(p0/dimProj))} 
      numProj=min(p0,numProj)
      d1=numProj
      
      indp=p0
      #sparseM=NULL
      #for (k in 1:ceiling(2*q*d/p)) {
      ind <- sample(1:indp, replace = FALSE);
      s = c(0,floor(quantile(1:indp, (1:d1)/d1)))
      sparseM1 <-cbind(ind, d2+rep(1:d1, s[-1] - s[-d1 - 1]), rep(1, indp))
    }
  }
  
  sparseM=rbind(sparseM,sparseM1)
  if (!is.null(catLabel)) {
    ind=sparseM[,1]; 
    catVar=which(ind<=length(catLabel))
    sparseM[-catVar, 1L]=sparseM[-catVar, 1L]+length(unlist(catLabel))-length(catLabel)
    
    catMap=1
    for (xj in unique(ind[catVar])) {
      isj=which(ind==xj)
      sparseM[isj, 1L]<- sample(catMap:(catMap+length(catLabel[[xj]])-1),length(isj),replace = FALSE)
      catMap=catMap+length(catLabel[[xj]])
    }
  }
  
  ##########################    
  if(n>10){
    Yi=c(y);indC=0L
    if(type!='regression'){
      y=as.factor(y)
      indC=levels(y)
      if(length(indC)>2){
        Yi=(matrix(y,n,length(indC))==matrix(indC,n,length(indC),byrow = TRUE))+0
      }else{
        Yi=as.integer(y)
      }
    }
    
    sparseM1=sparseM[d2+(1:indp),]
    sparseM=sparseM[-(d2+(1:indp)),]
    indTab=table(sparseM1[,2])
    ind=as.numeric(names(indTab)[which(indTab>1)])
    jx=which(sparseM1[,2]%in%ind)
    d11=min(max(c(indTab,d1)),length(unique(sparseM1[jx,1])))
    #d11=min(c(length(unique(sparseM[jx,1])),ifelse(type=='r',Inf,Inf)))#
    #d11=max(max(indTab),min(length(unique(sparseM1[jx,1])),d1)) 
    
    sparseM1=rbind(sparseM1,matrix(d1+d2+1,d11,3))
    for (ni in unique(sparseM1[,2L])) {
      lrows <- which(sparseM1[,2L] == ni)
      j.I <- sparseM1[lrows, 1L]
      if(ni==(d1+d2+1)){
        #jx=which(sparseM1[, 3L]!=1L)
        ix = order(abs(sparseM1[jx,3L]), decreasing = TRUE)
        j.I =unique(sparseM1[jx[ix],1])[1:d11]
        lrows=indp+(1:d11)
        sparseM1[lrows, 1L]=j.I
      }
      Xi <- X[, j.I, drop = FALSE]
      pi <- length(j.I)
      
      #S = eigen(cov(Xi))                # using PCA to handle the colinearity
      #Ii = 1:min(which((cumsum(S$values)+1e-4)/sum(S$values,1e-4) > 0.99))
      #Xi = Xi%*%S$vectors[,Ii, drop = FALSE]
      if (pi > 1L) {
        if(model=="PPR"){
          PP <- try(ppr(Xi, Yi,weights,nterms = 1, bass=1)$alpha, silent = TRUE)# sm.method="spline",sm.method="gcvspline"
        }else if(model=="Log"){
          if((n>5*pi)&(pi<10)){
            PP <- try(ppr(Xi, Yi, weights, nterms = 1, bass=1)$alpha, silent = TRUE)
          }else{
            #PP = try(nnet(Xi, y, size=1,trace=FALSE)$wts[2:(1+pi)], silent = TRUE)
            PP = nnet(y~Xi,weights, size=1,linout=TRUE,trace=FALSE)$wts[2:(1+pi)]#  
          }
        }else{
          PP <- PPO(Xi,y,model,type)
        }

        if(inherits(PP, "try-error")){
          LM = lm(Yi~.,data=data.frame(Xi),weights)
          if(length(indC)>2){
            
            theta.i=as.matrix(LM$coefficients)[-1,,drop = FALSE]
            for (j in seq(ncol(theta.i))) {
              theta.i[is.na(theta.i[,j]),j] = 0.0
            }
            theta.i = eigen(theta.i%*%t(theta.i))$vectors[,1]
            
          }else{
            theta.i=LM$coefficients[-1]
            theta.i[is.na(theta.i)] = 0.0
          }
          
        }else{
          theta.i=PP
        }
        
        #theta.i=S$vectors[,Ii]%*%theta.i
      }else{
        theta.i <- rep(1,pi)
      }
      
      theta.i=theta.i/sqrt(sum(theta.i^2))
      sparseM1[lrows, 3L] <- c(theta.i)
    }
    
    #sparseM1[,2]=sparseM1[,2]+d2
    #sparseM[d2+(1:p0),]=sparseM1
    sparseM=rbind(sparseM,sparseM1)
  }
  
  colnames(sparseM)=c("Variable","Number","Coefficient")
  return(sparseM)
}

##################################################################################
#' Create rotation matrix used to determine linear combination of mtry features.
#'
#' Create any projection matrix with a self-defined projection matrix function and projection optimization model function
#' 
#' @param X An n by d numeric matrix (preferable) or data frame.
#' @param y a n vector.
#' @param RotMatFun a self-defined projection matrix function name, which can also be \code{\link{RotMatRand}} and \code{\link{RotMatPPO}}. Note that \code{(,...)} is necessary.
#' @param PPFun a self-defined projection matrix function, which can also be \code{\link{PPO}}. Note that \code{(,...)} is necessary.
#' @param FunDir The path to the \code{function} of the user-defined \code{NodeRotateFun}. (default current Workspace)
#' @param paramList Parameters in a named list to be used.If left unchanged, default values will be populated, for details see \code{\link[ODRF]{defaults}}.
#' @param ... used to handle superfluous arguments passed in using paramList.
#'
#' @return \itemize{A random matrix to use in running \code{\link{ODT}}.
#' \item{Variable: variables to be projected.} 
#' \item{Number: Number of variables to be projected.}
#' \item{Coefficient: Coefficients of the projection matrix.}
#'}
#'
#' @seealso \code{\link{RotMatPPO}} \code{\link{RotMatRand}} \code{\link{RotMatRF}}
#'
#' @export
#'
#' @examples
#' X <- matrix(rnorm(200),20,10)
#' y <- (rnorm(20)>0)+0
#' set.seed(220828)
#' (RotMat <- RotMatMake(X,y,"RotMatRand","PPO"))
#' (RotMat <- RotMatMake(X,y,"RotMatPPO","PPO",paramList=list(model="Log")))
#' 
#' 
#' ## Self-defined projection matrix function and projection optimization model function.##
#' ## Note that (,...) is necessary.
#' makeRotMat=function(dimX,dimProj,numProj,...){
#'  RotMat=matrix(1,dimProj*numProj,3)
#'  for (np in seq(numProj)) {
#'    RotMat[(dimProj*(np-1)+1):(dimProj*np),1]=sample(1:dimX,dimProj,replace = FALSE)
#'    RotMat[(dimProj*(np-1)+1):(dimProj*np),2]=np
#'  }
#'  return(RotMat)
#' }
#' 
#' makePP=function(dimProj,prob,...){
#'   pp=sample(c(1L, -1L),dimProj, replace = TRUE,prob = c(prob, 1-prob))
#'  return(pp)
#' }
#' 
#' RotMat <- RotMatMake(RotMatFun="makeRotMat",PPFun="makePP",
#' paramList=list(dimX=8,dimProj=5,numProj=4,prob=0.5))
#' head(RotMat)
#' #     Variable Number Coefficient
#' #[1,]        3      1          -1
#' #[2,]        6      1           1
#' #[3,]        4      1          -1
#' #[4,]        7      1          -1
#' #[5,]        8      1           1
#' #[6,]        6      2          -1
#' 
RotMatMake <- function(X=NULL, y=NULL, RotMatFun="RotMatPPO", PPFun="PPO", FunDir=getwd(), paramList=NULL) {
  if(!is.null(X))
    X=as.matrix(X)
  
  if(NodeRotateFun=="RotMatPPO"){
    if(is.null(paramList$dimProj))
      paramList$dimProj =min(ceiling(length(y)^0.4),ceiling(ncol(X)*2/3))
    paramList$numProj=ifelse(paramList$dimProj=="Rand",max(5,sample(floor(ncol(X)/3),1)),max(5, ceiling(ncol(X)/paramList$dimProj)))
  }
  paramList = defaults(paramList,dimX = ncol(X))
  
  if((!RotMatFun%in%ls("package:ODRF"))&(!RotMatFun%in%ls())){
    source(paste0(FunDir,"/",RotMatFun,".R"))
  }
  if((!PPFun%in%ls("package:ODRF"))&(!RotMatFun%in%ls())){
    source(paste0(FunDir,"/",PPFun,".R"))
  }
  
  RotMatFun <- match.fun(RotMatFun, descend = TRUE)
  PPFun <- match.fun(PPFun, descend = TRUE)
  
  paramList$X=X;paramList$y=y
  sparseM <- do.call(RotMatFun, paramList)
  for (ni in unique(sparseM[,2L])) {
    lrows <- which(sparseM[,2L] == ni)
    paramList$X=X[,sparseM[lrows, 1L],drop = FALSE]
    sparseM[lrows, 3L]=do.call(PPFun, paramList)
  }
  
  paramList$X = NULL;paramList$y = NULL;
  
  colnames(sparseM)=c("Variable","Number","Coefficient")
  return(sparseM)
}

# roxygen2::roxygenise()
